TypeScript est un langage créé par Microsoft qui étend le Javascript (c'est un superset) en orienté objet avec des classes, des interfaces et du typage manuel.
Angular a été programmé en TypeScript. React utilise notamment ce langage.
Cross browser et cross platform.

TypeScript nécessite d'être installé sur la machine. Pour ce faire on utilise une commande du gestionnaire de paquet NPM de Node (celui-ci doit donc être installé) :

npm install -g typescript

Un fichier typescript porte l'extension .ts. Il ne peut pas être lu normalement (par le navigateur ou node), pour cela il a besoin d'être transcompilé en fichier js.
Pour ce faire, on doit utiliser la commande tsc nomDuFichier.ts qui créera le fichier .js alors exploitable.

Un des gros avantages du TS est qu'il intègre un déboggueur. Ce déboggeur relève les erreurs lors de chaque transcompilations. La transcompilation peut d'ailleurs être automatique 
en utilisant la commande tsc -w nomDuFichier.ts. L'idéal est d'utiliser un terminal intégré à l'éditeur de code (comme Visual Studio Code) afin de voir le résultat en temps réel.

Connaitre la version de TypeScript installée sur la machine : tsc -v

=== VARIABLES ET TYPAGE STATIQUE ===

Déclaration : 

-let nomVariable:type;
-var nomVariable:type;

Initialisation :

-let nomVariable:type = valeur;
-var nomVariable:type = valeur;

Affectation de valeur :

-nomVariable = valeur;

Différence entre var et let :
	-var : la variable est liée (scoped) à la fonction la plus proche
	-let : la variable est liée (scoped) au bloc de code le plus proche

const message:string = "test"; // Pour définir une constante dont la valeur ne pourra changer. Celle-ci doit être initialisée dès le départ.

=== TYPES ===

number, string, boolean, void, any, unknow, null, undefined, Date, never

On peut déclarer un array de deux façons : 
-let tableau:type[] = [val1, val2, val3...];
-let tableau:Array<type> = [val1, val2, val3...];

Un array peut avoir des types différents, cela se nomme le tuple type : 
let tableau:[type1, type2...] = [val1, val2...]; // Les valeurs doivent respecter l'ordre des types indiqués

On peut caster une variable comme ceci : (nomVariable as nomType) ou encore (<Type>nomVariable)

Une variable peut accepter plusieurs types : let nomVariable: type1 | type2...

function nom_fonction(param1:type, param2:type) :typeRetour{
	Instructions...
}

Connaitre le type d'une variable : typeof nomVariable

Créer ses propres types (structures de données) :

type nomType = {
	propriete: type;
	propriete: type;
	...
}

=== TYPAGE GENERIQUE ===

A l'instar de certains langages, il est possible de définir un type générique aux fonctions, classes ou interfaces.
Cela permet de vérifier la cohérence de typage avec divers éléments.

Exemple : function concatenate<X>(a: X[], b: X[]) :X[] { }

Les types passés en paramètre peuvent être de n'importe quel type mais doivent être similaires.

=== FONCTIONS ANONYMES FLECHEES (EXPRESSIONS LAMBDAS) ===

C'est un moyen plus rapide de déclarer une fonction anonyme :

(parametres) => { instructions... }

OU

let nomFonction = (parametres) => instruction; // ou { } si plusieurs lignes d'instructions

Les paramètres ne sont pas obligatoires.

Rendre un paramètre facultatif : le faire précéder d'un ?. 
PS : Une fois qu'un paramètre est rendu facultatif, tous les paramètres situés à sa droite le deviennent également.

"L'avantage par rapport à l'actuelle norme de JavaScript (ECMAScript 5), est que la notation fléchée ne change pas la valeur 
de contexte du mot-clé this à l'intérieur de la fonction anonyme. Cela évite donc l'utilisation d'une variable intermédiaire 
servant à propager la valeur de this à l'intérieur de la fonction anonyme."

=== ENUMERATIONS ===

-enum NomEnum = {val1, val2, val3...}; // val1 renverra 0, val2 renverra 1 etc...
-enum NomEnum = {val1 = 5, val2, val3 = 12...} // val1 renverra 5, val2 renverra 6, val3 renverra 12...

Accès : nomEnum.val

=== INTERFACES ===

interface nomInterface {
	nomPropriete:type;
	nomMethod():type { }
}

Un objet ou une classe implémentant une interface doit avoir les propriétés et méthodes correspondantes.

Extension d'interface : interface b extends a.

Rendre une propriété optionnelle : ajouter un ? après le nom de la propriété
Rendre une propriété en lecture seule : ajouter readonly avant le nom de la propriété

== CLASSES ET OBJETS ===

class nomClasse {

	constructor(parametres) {
		// LE CONSTRUCTEUR EST UNE FONCTION QUI SE DECLENCHE A LA CREATION D'UN OBJET DE LA CLASSE
	}


	propriete:type = valeur;

	method():type {
		// INSTRUCTIONS DE LA FONCTION / PROCEDURE
	}
}

Extension de classe : class Lion extends Animal

let obj = new nomClasse(); // new permet l'allocation dynamique de mémoire
obj.greet();

Il est possible de rendre private / protected / public les propriétés et méthodes d'une classe.

Un moyen rapide de déclarer des propriétés et de les initialiser est de déclarer les propriétés dans la déclaration du constructeur de la classe.
Exemple : constructor(private val1:number, private val2:number...) { }

On peut également mettre des fonctions getters et setters pour accéder ou modifier des propriétés privées via les objets.

get nomGetter() { return this.propriete }

set nomSetter(parametre) { this.propriete = parametre }

/!\ Lors de la transcompilation, il faut savoir que la norme de nommage camelCase est utilisée, hors si on appelle les getters et setters avec le même nom en majuscule des propriétés, il va y avoir une erreur.
Pour la remédier, il est préférable de mettre lors de la déclaration des propriétés un _ devant leur nom.

L'accès aux propriétés et méthodes d'un objet actuel au sein d'une classe se fait avec le mot clef this.


=== MODULES ===

En TS, l'organisation des fichiers est dite modulaire. Il est recommandé de créer un fichier par classe. Chaque fichier est un module que l'on peut exporter et importer dans d'autres.

Pour créer un module (espace de nommage), il faut utiliser la notation module nomModule { le code ici... }

Ajouter le mot clef export devant une classe pour permettre son importation dans d'autres fichiers. On peut aussi le faire
pour des variables, fonctions et interfaces.

Utiliser le mot clef import { NomDeLaClasse } from { './lienDuFichierSansExtension' } pour importer un module.
Ou encore : import nomModule = require("lienVersFichierSansExtension");

=== DECORATEURS ===

Déclaration attachée à une classe, une méthode ou une propriété. Précédé d'un @. 
Exemple : @Component({

})

=== TSCONFIG ===

Fichier permettant de configurer le compiler typescript du projet.
Créer le fichier avec la commande tsc --init

=== DIVERS ===

Vidéos explicatives : 
https://www.youtube.com/watch?v=NjN00cM18Z4
https://www.youtube.com/watch?v=WBPrJSw7yQA
