TypeScript est un langage qui étend le Javascript (superset) en orienté objet avec des classes, des interfaces et du typage manuel.
Angular 2.0 a été programmé en TypeScript. Anders Hejlsberg (designer du C#) a inventé le langage.
Cross browser et cross platform.

Fichier TypeScript : .ts_nomFichierTS pour transcompiler un fichier TS en JS.

Le TS permet notamment de repérer les erreurs lors de la compilation et dans l'éditeur de code.

=== VARIABLES ET TYPAGE STATIQUE ===

let message:type = valeur;
OU var message:type = valeur;

Différence entre var et let :
	-var : la variable est liée (scoped) à la fonction la plus proche
	-let : la variable est liée (scoped) au bloc de code le plus proche

=== TYPAGE GENERIQUE ===

A l'instar de certains langages, il est possible de définir un type générique aux fonctions, classes ou interfaces.
Cela permet de vérifier la cohérence de typage avec divers éléments.

Exemple : function concatenate<X>(a: X[], b: X[]) :X[] { }

Les types passés en paramètre peuvent être de n'importe quel type mais doivent être similaires.

=== FONCTIONS ANONYMES FLECHEES (EXPRESSIONS LAMBDAS) ===

C'est un moyen plus rapide de déclarer une fonction anonyme :

(parametres) => { instructions... }

OU

let nomFonction = (parametres) => instruction; // ou { } si plusieurs lignes d'instructions

Les paramètres ne sont pas obligatoires.

Rendre un paramètre facultatif : le faire précéder d'un ?. 
PS : Une fois qu'un paramètre est rendu facultatif, tous les paramètres situés à sa droite le deviennent également.

"L'avantage par rapport à l'actuelle norme de JavaScript (ECMAScript 5), est que la notation fléchée ne change pas la valeur 
de contexte du mot-clé this à l'intérieur de la fonction anonyme. Cela évite donc l'utilisation d'une variable intermédiaire 
servant à propager la valeur de this à l'intérieur de la fonction anonyme."

=== ENUMERATIONS ===

enum nomEnum = [val1 = 0, val2 = 1, val3 = 2...];

Accès : nomEnum.val

=== INTERFACES ===

interface nomInterface {
	nomPropriete:type;
	nomMethod():type { }
}

Un objet ou une classe implémentant une interface doit avoir les propriétés et méthodes correspondantes.

Extension d'interface : interface b extends a.

== CLASSES ET OBJETS ===

class nomClasse {

	constructor(parametres) {
		// LE CONSTRUCTEUR EST UNE FONCTION QUI SE DECLENCHE A LA CREATION D'UN OBJET DE LA CLASSE
	}


	propriete:type = valeur;

	method():type {
		// INSTRUCTIONS DE LA FONCTION / PROCEDURE
	}
}

Extension de classe : class Lion extends Animal

let obj = new nomClasse(); // new permet l'allocation dynamique de mémoire
obj.greet();

Il est possible de rendre private / protected / public les propriétés et méthodes d'une classe.

Un moyen rapide de déclarer des propriétés et de les initialiser est de déclarer les propriétés dans la déclaration du constructeur de la classe.
Exemple : constructor(private val1:number, private val2:number...) { }

On peut également mettre des fonctions getters et setters pour accéder ou modifier des propriétés privées via les objets.

get nomGetter() { return this.propriete }

set nomSetter(parametre) { this.propriete = parametre }

/!\ Lors de la transcompilation, il faut savoir que la norme de nommage camelCase est utilisée, hors si on appelle les getters et setters avec le même nom en majuscule des propriétés, il va y avoir une erreur.
Pour la remédier, il est préférable de mettre lors de la déclaration des propriétés un _ devant leur nom.

L'accès aux propriétés et méthodes d'un objet actuel au sein d'une classe se fait avec le mot clef this.

=== TYPES ===

Number, String, Boolean, Void, Any

On peut déclarer un array comme ceci : type[] = [val1, val2, val3...];

=== MODULES ===

En TS, l'organisation des fichiers est dite modulaire. Il est recommandé de créer un fichier par classe. Chaque fichier est un module que l'on peut exporter et importer dans d'autres.

Pour créer un module (espace de nommage), il faut utiliser la notation module nomModule { le code ici... }

Ajouter le mot clef export devant une classe pour permettre son importation dans d'autres fichiers. On peut aussi le faire
pour des variables, fonctions et interfaces.

Utiliser le mot clef import { nomDeLaClasse } from { location } pour importer un module.
Ou encore : import nomModule = require("lienVersFichierSansExtension");

=== DECORATEURS ===

Déclaration attachée à une classe, une méthode ou une propriété. Précédé d'un @. 
Exemple : @Component({

})

=== DIVERS ===

Vidéo explicative : https://www.youtube.com/watch?v=NjN00cM18Z4
